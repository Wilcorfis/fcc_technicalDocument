<script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
<nav id="navbar">
  <header>Manual de Node.js</header>
  <ul>
    <li><a class="nav-link" href="#javascript_node">javascript node</a></li>
    <li><a class="nav-link" href="#holamundo">holamundo</a></li>
    <li><a class="nav-link" href="#pila_aplicaciones">pila aplicaciones</a></li>
    <li><a class="nav-link" href="#cons_pila">cons pila</a></li>
    <li><a class="nav-link" href="#servidor_http">servidor http</a></li>
    <li><a class="nav-link" href="#pasando_funciones">pasando funciones</a></li>
    <li><a class="nav-link" href="#servidor_prueba">servidor prueba</a></li>
    <li><a class="nav-link" href="#callbacks_eventos">callbacks eventos</a></li>
    <li><a class="nav-link" href="#manipula_peticion">manipula peticion</a></li>
    <li><a class="nav-link" href="#modulo_servidor">modulo servidor</a></li>
    <li><a class="nav-link" href="#rutear_peticiones">rutear peticiones</a></li>
    <li><a class="nav-link" href="#rutear_manipulador">rutear manipulador</a></li>
    <li><a class="nav-link" href="#referencia">referencia</a></li>
  </ul>
</nav>
<main id="main-doc">
  <section class="main-section" id="javascript_node">
    <header>javascript node</header>
    <article>
    
    <h3>JavaScript y Tú</h3>
    <p>
        Antes que hablemos de toda la parte técnica, tomémonos
        un minuto y hablemos acerca de ti y tu relación con 
        JavaScript. Este capítulo está aquí para permitirte estimar
        si tiene sentido el que sigas o no leyendo este documento.
    </p>
    <p>
        Si eres como yo, empezaste con el "desarrollo" HTML
        hace bastante tiempo, escribiendo documentos HTML. Te 
        encontraste en el camino con esta cosa simpática llamada
        JavaScript, pero solo la usabas en una forma muy básica,
        agregando interactividad a tus páginas de cuando en cuando.
    </p>
    <p>
        Lo que realmente quisiste era "la cosa real", querías
        saber cómo construir sitios web complejos - Aprendiste un
        lenguaje de programación como PHP, Ruby, Java, y empezaste a 
        escribir código "backend".
    </p>
    <p>
        No obstante, mantuviste un ojo en JavaScript, y te diste
        cuenta que con la introducción de jQuery, Prototype y otros,
        las cosas se fueron poniendo más avanzadas en las Tierras
        de JavaScript, y que este lenguaje era realmente más que
        hacer un <em>window.open()</em>.                            
    </p>
    <p>
        Sin embargo, esto era todo cosa del 
        <span style="font-style: italic;">frontend</span>, y aunque era
        agradable contar con jQuery a tu disposición en cualquier
        momento que te sintieras con ánimo de sazonar una página web,
        al final del día, lo que eras a lo más, era un usuario de JavaScript,
        pero no, un desarrollador de JavaScript.
    </p>
    <p>
        Y entonces llegó Node.js. JavaScript en el servidor, ¿Qué
        hay con eso?                
    </p>
    <p>
        Decidiste que era ya tiempo de revisar el nuevo JavaScript.
        Pero espera: Escribir aplicaciones Node.js es una cosa; Entender
        el por qué ellas necesitan ser escritas en la manera que lo son
        significa entender JavaScript! Y esta vez es en serio.
    </p>
    <p>
        Y aquí está el problema: Ya que JavaScript realmente vive
        dos, o tal vez tres vidas (El pequeño ayudante DHTML de 
        mediados de los 90's, las cosas más serias tales como jQuery
        y similares, y ahora, el lado del servidor), no es tan fácil
        encontrar información que te ayude a aprender JavaScript de la
        "manera correcta", de forma de poder escribir aplicaciones de 
        Node.js en una apariencia que te haga sentir que no sólo
        estás usando JavaScript, sino que también están desarrollando
        con él.
    </p>
    <p>            
        Porque ahí está el asunto: Ya eres un desarrollador
        experimentado, y no quieres aprender una nueva técnica
        simplemente metiendo código aquí y allá mal-aprovechándolo;
        Quieres estar seguro que te estás enfocando en un ángulo
        correcto.
    </p>
    <p>
        Hay, por supuesto, excelente documentación afuera.
        Pero la documentación por sí sola no es suficiente. Lo que 
        se necesita es una guía.
    </p>
    <p>
        Mi objetivo es proveerte esta guía.
    </p>

    <h3>Una Advertencia</h3>
    <p>
         Hay algunas personas realmente excelente en JavaScript.
         No soy una de ellas.
    </p>
    <p>
         Yo soy realmente el tipo del que te he hablado en los
         párrafos previos. Sé un par de cosas acerca de desarrollar
         aplicaciones backend, pero aún soy nuevo al JavaScript "real"
         y aún más nuevo a Node.js. He aprendido solo recientemente alguno 
         de los aspectos avanzados de JavaScript. No soy experimentado.
    </p>
    <p>
        Por lo que este no es un libro "desde novicio hasta experto".
        Este es más bien un libro "desde novicio a novicio avanzado".
    </p>
    <p>
        Si no fallo, entonces este será el tipo de documento
        que deseo hubiese tenido cuando empecé con Node.js.
    </p>

    <h3>JavaScript del Lado del Servidor</h3>
    <p>
        Las primeras encarnaciones de JavaScript vivían en los
        browsers. Pero esto es sólo el contexto. Define lo que puedes
        hacer con el lenguaje, pero no dice mucho acerca de lo que el
        lenguaje mismo puede hacer. JavaScript es un lenguaje "completo":
        Lo puedes usar en muchos contextos y alcanzar con éste, todo
        lo que puedes alcanzar con cualquier otro lenguaje "completo".
    </p>
    <p>
        Node.js realmente es sólo otro contexto: te permite correr
        código JavaScript en el backend, fuera del browser.
    </p>
    <p>
        Para ejecutar el código JavaScript que tu pretendes correr en el 
        backend, este necesita ser interpretado y, bueno, ejecutado, Esto
        es lo que Node.js realiza, haciendo uso de la Maquina Virtual V8 de
        Google, el mismo entorno de ejecución para JavaScript que Google
        Chrome utiliza.
    </p>
    <p>
        Además, Node.js viene con muchos módulos útiles, de manera que no
        tienes que escribir todo de cero, como por ejemplo, algo que ponga un
        string a la consola.
    </p>
    <p>
        Entonces, Node.js es en realidad dos cosas: un entorno de ejecución
        y una librería.
    </p>
    <p>
        Para hacer uso de éstas (la librería y el entorno), necesitas
        instalar Node.js. En lugar de repetir el proceso aquí, te ruego
        visitar <a href="https://github.com/joyent/node/wiki/Installation"
           title="Building and Installing Node.js">las instrucciones oficiales
        de instalación</a>. Por favor vuelve una vez que tengas tu versión de
        Node.js corriendo.
    </p>
    
    
    </article>
  </section>
  
  
  <section class="main-section" id="holamundo">
    <header>holamundo</header>
    <article>
       
    <p>
    Ok. Saltemos entonces al agua fría y escribamos nuestra primera
        aplicación Node.js: "Hola Mundo".                
    </p>
    <p>
        Abre tu editor favorito y crea un archivo llamado <em>holamundo.js</em>.
        Nosotros queremos escribir "Hola Mundo" a STDOUT, y aquí está el código
        necesario para hacer esto:            
    </p>
<code class="prettyprint lang-js">console.log("Hola Mundo");
</code>
    <p>
        Graba el archivo, y ejecútalo a través de Node.js:
    </p>
<code class="prettyprint lang-js">node holamundo.js</code>
    <p>
        Este debería retornar <em>Hola Mundo</em> en tu monitor.
    </p>
    <p>
        Ok, esto es aburrido, de acuerdo? Así que escribamos alguna cosa real.
    </p>    
    
    <h2>Una Aplicación Web Completa con Node.js</h2>
    
    <h3>Los casos de Uso</h3>
    <p>
        Mantengámoslo simple, pero realista:
    </p>
    <ul>
        <li>
            El Usuario debería ser capaz de ocupar nuestra aplicación con
            un browser.
        </li>
        <li>
            El Usuario debería ver una página de bienvenida cuando
            solicita http://<em>dominio</em>/inicio, la cual despliega
            un formulario de subida.
        </li>
        <li>
            Eligiendo un archivo de imagen para subir y enviando
            el formulario, la imagen debería ser subida a 
            http://<em>dominio</em>/subir, donde es desplegada una
            vez que la subida este finalizada.                    
        </li>
    </ul>
    <p>
        Muy bien. Ahora, tu puedes ser capaz de alcanzar este objetivo
        googleando y programando <em>lo que sea</em>, pero eso no es lo
        que queremos hacer aquí.
    </p>
    <p>
        Más que eso, no queremos escribir simplemente el código más
        básico posible para alcanzar este objetivo, no importa lo
        elegante y correcto que pueda ser este código. Nosotros
        agregaremos intencionalmente más abstracción de la necesaria
        de manera de poder tener una idea de lo que es construir 
        aplicaciones más complejas de Node.js.
    </p>


    </article>
  </section>
  <section class="main-section" id="pila_aplicaciones">
    <header>pila aplicaciones</header>
    <article>
   
    <p>
        Hagamos un desglose a nuestra aplicación. ¿Qué partes
        necesitan ser implementadas para poder satisfacer
        nuestros casos de uso?
    </p>
    <ul>
        <li>
            Queremos servir páginas web, de manera que necesitamos
            un <strong>Servidor HTTP</strong>.
        </li>
        <li>
            Nuestro servidor necesitará responder directamente
            peticiones (requests), dependiendo de qué URL sea pedida en
            este requerimiento, es que necesitaremos algún tipo
            de <strong>enrutador (router)</strong> de manera de
            mapear los peticiones a los handlers (manejadores) de éstos.
        </li>
        <li>
            Para satisfacer a los peticiones que llegaron 
            al servidor y han sido ruteados usando el enrutador,
            necesitaremos de hecho 
            <strong>handlers (manejadores) de peticiones</strong>
        </li>
        <li>
            El Enrutador probablemente debería tratar cualquier
            información POST que llegue y dársela a los handlers de
            peticiones en una forma conveniente, luego 
            necesitaremos <strong>manipulación de data de petición</strong>
        </li>
        <li>
            Nosotros no solo queremos manejar peticiones de URLs,
            sino que también queremos desplegar contenido cuando
            estas URLs sean pedidas, lo que significa que necesitamos
            algún tipo de <strong>lógica en las vistas</strong> a
            ser utilizada por los handlers de peticiones, de manera
            de poder enviar contenido al browser del Usuario.
        </li>
        <li>
            Por último, pero no menos importante, el Usuario será
            capaz de subir imágenes, así que necesitaremos algún 
            tipo de <strong>manipulación de subidas</strong> quien
            se hará cargo de los detalles.
        </li>
    </ul>
    <p>
        Pensemos un momento acerca de como construiríamos esta pila
        de aplicaciones con PHP. No es exactamente un secreto que
        la configuración típica sería un Apache HTTP server con 
        mod_php5 instalado.
        <br/>
        Lo que, a su vez, significa que el tema "Necesitamos ser capaces
        de servir páginas web y recibir peticiones HTTP" ni siquiera
        sucede dentro de PHP mismo.
    </p>
    <p>
        Bueno, con Node.js, las cosas son un poco distintas. Porque
        con Node.js, no solo implementamos nuestra aplicación, nosotros
        también implementamos todo el servidor HTTP completo.
        De hecho, nuestra aplicación web y su servidor web son
        básicamente lo mismo.
    </p>
    <p>
        Esto puede sonar como mucho trabajo, pero veremos en un momento
        que con Node.js, no lo es.
    </p>            
    <p>                
        Empecemos por el principio e implementemos la primera parte
        de nuestra pila, el servidor HTTP..
    </p>

    </article>
  </section>
  <section class="main-section" id="cons_pila">
    <header>cons pila</header>
    <article>
     
    <h3>Un Servidor HTTP Básico</h3>
    <p>
        Cuando llegué al punto donde quería empezar con mi primera
        aplicación Node.js "real", me pregunté no solo como la iba
        a programar, sino que también, como organizar mi código.
        <br/>
        ¿Necesitaré tenerlo todo en un archivo? Muchos tutoriales en
        la Web que te enseñan cómo escribir un servidor HTTP básico en
        Node.js tienen toda la lógica en un solo lugar. ¿Qué pasa
        si yo quiero asegurarme que mi código se mantenga leíble a 
        medida que le vaya agregando más cosas?
    </p>
    <p>
        Resulta, que es relativamente fácil de mantener los 
        distintos aspectos de tu código separados, poniéndolos en
        módulos.
    </p>
    <p>
        Esto te permite tener un archivo <em>main</em> limpio, en
        el cual ejecutas Node.js, y módulos limpios que pueden ser
        utilizados por el archivo <em>main</em> entre muchos otros.
    </p>
    <p>
        Así que vamos a crear un archivo <em>main</em> el cual usaremos
        para iniciar nuestra aplicación, y un archivo de módulo dónde
        residirá el código de nuestro servidor HTTP.
    </p>
    <p>
        Mi impresión es que es más o menos un estándar nombrar a tu
        archivo <em>principal</em> como <em>index.js</em>. Tiene sentido
        también que pongamos nuestro módulo de servidor en un archivo
        llamado <em>server.js</em>.
    </p>
    <p>
        Empecemos con el módulo del servidor. Crea el archivo
        <em>server.js</em> en el directorio raíz de tu proyecto,
        y llénalo con el código siguiente:
    </p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}).listen(8888);
</pre>

    <p>
        Eso es! Acabas de escribir un servidor HTTP activo. Probémoslo
        ejecutándolo y testeándolo. Primero ejecuta tu script con Node.js:
    </p>
<pre class="prettyprint lang-js">node server.js</pre>
    <p>
        Ahora, abre tu browser y apúntalo a
        <a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>.
        Esto debería desplegar una página web que diga "Hola Mundo".
    </p>
    <p>
    Interesante, ¿no? ¿Qué tal si hablamos de que está pasando aquí y
    dejamos la pregunta de 'cómo organizar nuestro proyecto' para después?
    Prometo que volveremos a esto.
    </p>


    </article>
  </section>
  
  <section class="main-section" id="servidor_http">
    <header>servidor http</header>
    
    
    <p>
        Bueno, entonces, analicemos que está pasando aquí.
    </p>
    <p>
        La primera línea <em>require</em>, requiere al módulo <em>http</em>
        que viene incluido con Node.js y lo hace accesible a través de la
        variable <em>http</em>.
    </p>
    <p>
        Luego llamamos a una de las funciones que el módulo http ofrece:
        <em>createServer</em>. Esta función retorna un objeto, y este objeto
        tiene un método llamado <em>listen</em> (escucha), y toma un
        valor numérico que indica el número de puerto en que nuestro
        servidor HTTP va a escuchar.
    </p>
    <p>
        Por favor ignora por un segundo a la definición de función
        que sigue a la llave de apertura de <em>http.createServer</em>.
    </p>
    <p>
        Nosotros podríamos haber escrito el código que inicia a nuestro
        servidor y lo hace escuchar al puerto 8888 de la siguiente manera:
    </p>
<code>var http = require("http");
var server = http.createServer();
server.listen(8888);</code>
    <p>
        Esto hubiese iniciado al servidor HTTP en el puerto 8888
        y no hubiese hecho nada más (ni siquiera respondido alguna
        petición entrante).
    </p>
    <p>
        La parte realmente interesante (y rara, si tu trasfondo es 
        en un lenguaje más conservador, como PHP) es que la definición
        de función está ahí mismo donde uno esperaría el primer
        parámetro de la llamada a <em>createServer()</em>.
    </p>
    <p>
        Resulta que, este definición de función ES el primer
        (y único) parámetro que le vamos a dar a la llamada a
        <em>createServer()</em>. Ya que en JavaScript, las funciones
        pueden ser pasadas de un lado a otro como cualquier otro valor.
    </p>
   
  </section>
  
  <section class="main-section" id="pasando_funciones">
    <header>pasando funciones</header>
    <article>  
    <p>
        Puedes, por ejemplo, hacer algo como esto:                
    </p>
<code >function decir(palabra) {
  console.log(palabra);
}

function ejecutar(algunaFuncion, valor) {
  algunaFuncion(valor);
}

ejecutar(decir, "Hola");</code>
    <p>
        Lee esto cuidadosamente! Lo que estamos haciendo aquí es,
        nosotros pasamos la función <em>decir()</em> como el primer
        parámetro de la función <em>ejecutar</em>. No el valor de retorno
        de <em>decir</em>, sino que <em>decir()</em> misma!
    </p>            
    <p>
        Entonces, <em>decir</em> se convierte en la variable local
        <em>algunaFuncion</em> dentro de <em>ejecutar</em>, y ejecutar
        puede llamar a la función en esta variable usando 
        <em>algunaFuncion()</em> (agregando llaves).
    </p>
    <p>
        Por supuesto, dado que <em>decir</em> toma un parámetro,
        <em>ejecutar</em> puede pasar tal parámetro cuando llama a
        <em>algunaFuncion</em>.
    </p>
    <p>
        Nosotros podemos, tal como lo hicimos, pasar una función
        por su nombre como parámetro a otra función. Pero no
        estamos obligados a tener que definir la función primero
        y luego pasarla. Podemos también definir y pasar la función
        como un parámetro a otra función todo al mismo tiempo:
    </p>
<code>function ejecutar(algunaFuncion, valor) {
  algunaFuncion(valor);
}

ejecutar(function(palabra){ console.log(palabra) }, "Hola");
</code>
    <p>
        (N.del T.: <em>function</em> es una palabra clave de JavaScript).
    </p>
    <p>
        Nosotros definimos la función que queremos pasar a <em>ejecutar</em>
        justo ahí en el lugar donde <em>ejecutar</em> espera su primer
        parámetro.
    </p>
    <p>
        De esta manera, no necesitamos darle a la función un nombre,
        por lo que esta función es llamada <em>función anónima</em>.
    </p>
    <p>
        Esta es una primera ojeada a lo que me gusta llamar JavaScript
        "avanzado". Pero tomémoslo paso a paso. Por ahora, aceptemos que
        en JavaScript, nosotros podemos pasar una función como un parámetro
        cuando llamamos a otra función. Podemos hacer esto asignando
        nuestra función a una variable, la cual luego pasamos, o definiendo
        la función a pasar en el mismo lugar.
    </p>
    </article>
  </section>
  <section class="main-section" id="servidor_prueba">
    <header>servidor prueba</header>
    <article>
     
    <p>
        Con este conocimiento, Volvamos a nuestro servidor HTTP
        minimalista:
    </p>
<code>var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}).listen(8888);
</code>
    <p>
        A estas alturas, debería quedar claro lo que estamos haciendo acá:
        Estamos pasándole a la función <em>createServer</em> una función
        anónima.
    </p>
    <p>
        Podemos llegar a lo mismo refactorizando nuestro código así:
    </p>
<code>var http = require("http");

function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}

http.createServer(onRequest).listen(8888);
</code>
    <p>
        Quizás ahora es un buen momento para preguntar:
        ¿Por Qué estamos haciendo esto de esta manera?                
    </p>

    </article>
  </section>
  <section class="main-section" id="callbacks_eventos">
    <header>callbacks eventos</header>
    <article>
      
        
    <p>
        La respuesta a) No es algo fácil de explicar (al menos para mí),
        y b) Yace en la naturaleza misma de como Node.js trabaja:
        Está orientado al evento, esa es la razón de por qué es tan
        rápido.
    </p>
    <p>
        Podrías tomarte un tiempo para leer este excelente post (en inglés)
        de Felix Geisendördfer: <a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding node.js</a> para alguna explicación de trasfondo.
    </p>
    <p>
        Al final todo se reduce al hecho que Node.js trabaja orientado
        al evento. Ah, y sí, yo tampoco sé exactamente qué significa eso.
        Pero voy a hacer un intento de explicar, el por qué esto tiene
        sentido para nosotros, que queremos escribir aplicaciones
        web en Node.js.            
    </p>
    <p>
        Cuando nosotros llamamos al método <em>http.createServer</em>,
        por supuesto que no sólo queremos que el servidor se quede escuchando
        en algún puerto, sino que también queremos hacer algo cuando hay
        una petición HTTP a este servidor.
    </p>
    <p>
        El problema es, que esto sucede de manera asíncrona: Puede
        suceder en cualquier momento, pero solo tenemos un único proceso
        en el cual nuestro servidor corre.
    </p>
    <p>
        Cuando escribimos aplicaciones PHP, esto no nos molesta en
        absoluto: cada vez que hay una petición HTTP, el servidor web
        (por lo general Apache) genera un nuevo proceso solo para esta
        petición, y empieza el script PHP indicado desde cero, el cual
        es ejecutado de principio a fin.
    </p>
    <p>
        Así que respecto al control de flujo, estamos en el medio de
        nuestro programa en Node.js, cuando una nueva petición llega al
        puerto 8888: ¿Cómo manipulamos esto sin volvernos locos?
    </p>
    <p>
        Bueno, esta es la parte donde el diseño orientado al evento
        de Node.js / JavaScript de verdad ayuda, aunque tengamos
        que aprender nuevos conceptos para poder dominarlo. Veamos
        como estos conceptos son aplicados en nuestro código de
        servidor.
    </p>
    <p>
        Nosotros creamos el servidor, y pasamos una función al método
        que lo crea. Cada vez que nuestro servidor recibe una petición,
        la función que le pasamos será llamada.
    <p>
        No sabemos qué es lo que va a suceder, pero ahora tenemos un
        lugar donde vamos a poder manipular la petición entrante.
        Es la función que pasamos, sin importar si la definimos o si
        la pasamos de manera anónima.
    </p>
    <p>
        Este concepto es llamado un <em>callback</em> (N. del T.: del inglés: call =
        llamar; y back = de vuelta). Nosotros pasamos una función a algún
        método, y el método ocupa esta función para llamar (call) de vuelta
        (back) si un evento relacionado con este método ocurre.
    </p>
    <p>
        Al menos para mí, esto tomó algún tiempo para ser entendido. Lee
        el articulo del blog de Felix de nuevo si todavía no te sientes
        seguro.
    </p>
    <p>
        Juguemos un poco con este nuevo concepto. ¿Podemos probar que nuestro
        código continúa después de haber creado el servidor, incluso
        si no ha sucedido ninguna petición HTTP y la función callback que
        pasamos no ha sido llamada? Probemos:
    </p>
<code>var http = require("http");

function onRequest(request, response) {
  console.log("Peticion Recibida.");
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}

http.createServer(onRequest).listen(8888);

console.log("Servidor Iniciado.");
</code>
    <p>
        Noten que utilizo <em>console.log</em> para entregar un texto
        cada vez que la función <em>onRequest</em> (nuestro callback) es
        gatillada, y otro texto <em>después</em> de iniciar nuestro servidor
        HTTP.
    </p>
    <p>
        Cuando iniciamos esta aplicación (con <em>node server.js</em>, como siempre).
        Esta inmediatamente escribirá en pantalla "Servidor Iniciado" en la línea de comandos.
        Cada vez que hagamos una petición a nuestro servidor (abriendo
        <a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a> en
        nuestro browser), el mensaje "Peticion Recibida." va a ser impreso en la línea
        de comandos.
    </p>    
    <p>
        Esto es JavaScript del lado del servidor asíncrono y orientado al
        evento con callbacks en acción :-)
    </p>
    <p>
        (Toma en cuenta que nuestro servidor probablemente escribirá
        "Petición Recibida." a STDOUT dos veces al abrir la página en un
        browser. Esto es porque la mayoría de los browsers van a tratar de
        cargar el favicon mediante la petición http://localhost:8888/favicon.ico
        cada vez que abras http://localhost:8888/).
    </p>
    </article>
  </section>
  <section class="main-section" id="manipula_peticion">
    <header>manipula peticion</header>
    <article>
    
        
    <p>
        OK, analicemos rápidamente el resto del código de nuestro servidor,
        esto es, el cuerpo de nuestra función de callback <em>onRequest()</em>.
    </p>
    <p>
        Cuando la callback es disparada y nuestra función <em>onRequest()</em> es
        gatillada, dos parámetros son pasados a ella: <em>request</em> y <em>response</em>.
    </p>
    <p>
        Estos son objetos, y puedes usar sus métodos para manejar los detalles
        de la petición HTTP ocurrida y responder a la petición (en otras palabras
        enviar algo de vuelta al browser que hizo la petición a tu servidor).
    </p>
    <p>
        Y eso es lo que nuestro código hace: cada vez que una petición
        es recibida, usa la función <em>response.writeHead()</em> para 
        enviar un estatus HTTP 200 y un content-type (parámetro que define
        que tipo de contenido es) en el encabezado de la respuesta HTTP,
        y la función <em>response.write()</em> para enviar el texto
        "Hola Mundo" en el cuerpo de la respuesta.
    </p>
    <p>
        Por último, nosotros llamamos <em>response.end()</em> para finalizar
        nuestra respuesta.
    </p>
    <p>
        Hasta el momento, no nos hemos interesado por los detalles de la
        petición, y ese es el por qué no hemos ocupado el objeto <em>request</em>
        completamente.
    </p>
    </article>
  </section>
  <section class="main-section" id="modulo_servidor">
    <header>modulo servidor</header>
    <article>
    
    <p>
        OK, prometí que volveríamos a al Cómo organizar nuestra aplicación.
        Tenemos el código de nuestro servidor HTTP muy básico en el archivo
        <em>server.js</em>, y mencioné que es común tener un archivo principal
        llamado <em>index.js</em>, el cual es usado para arrancar y partir
        nuestra aplicación haciendo uso de los otros módulos de la aplicación
        (como el módulo de servidor HTTP que vive en <em>server.js</em>).
    </p>
    <p>
        Hablemos de como podemos hacer que nuestro server.js sea un verdadero
        módulo Node.js y que pueda ser usado por nuestro pronto-a-ser-escrito
        archivo principal <em>index.js</em>.
    </p>
    <p>
        Como habrán notado, ya hemos usado módulos en nuestro código, como éste:
    </p>
<code>var http = require("http");

...

http.createServer(...);
</code>
    <p>
        En algún lugar dentro de Node.js vive un módulo llamado "http", y
        podemos hacer uso de éste en nuestro propio código requiriéndolo
        y asignando el resultado del requerimiento a una variable local.
    </p>
    <p>
        Esto transforma a nuestra variable local en un objeto que acarrea
        todos los métodos públicos que el módulo <em>http</em> provee.
    </p>
    <p>
        Es práctica común elegir el nombre del módulo como nombre para nuestra
        variable local, pero somos libres de escoger cualquiera que nos guste:
    </p>
<code>var foo = require("http");

...

foo.createServer(...);
</code>
    <p>
        Bien. Ya tenemos claro como hacer uso de los módulos internos de Node.js.
        ¿Cómo hacemos para crear nuestros propios módulos, y Cómo los utilizamos?
    </p>
    <p>
        Descubrámoslo transformando nuestro script <em>server.js</em> en un módulo
        real.
    </p>
    <p>
        Sucede que, no tenemos que transformarlo tanto. Hacer que algún código sea
        un Módulo, significa que necesitamos <em>exportar</em> las partes de su
        funcionalidad que queremos proveer a otros scripts que requieran nuestro
        módulo.
    </p>
    <p>
        Por ahora, la funcionalidad que nuestro servidor HTTP necesita exportar es
        simple: Permitir a los scripts que utilicen este módulo arrancar el servidor.
    </p>
    <p>
        Para hacer esto posible, dotaremos al código de nuestro servidor de una
        función llamada <em>inicio</em>, y exportaremos esta función:
    <p>
<code>var http = require("http");

function iniciar() {
  function onRequest(request, response) {
    console.log("Petición Recibida.");
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hola Mundo");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Servidor Iniciado.");
}

exports.iniciar = iniciar;
</code>    
    <p>
        De este modo, Podemos crear nuestro propio archivo principal <em>index.js</em>,
        y arrancar nuestro servidor HTTP allí, aunque el código para el servidor este
        en nuestro archivo <em>server.js</em>.
    </p>
    <p>
        Crea un archivo <em>index.js</em> con el siguiente contenido:
    </p>
<code>var server = require("./server");

server.iniciar();
</code>
    <p>
        Como puedes ver, nosotros utilizamos nuestro módulo de servidor
        tal como cualquier otro módulo interno: requiriendo el archivo
        donde está contenido y asignándolo a una variable, con las funciones
        que tenga 'exportadas' disponibles para nosotros.
    </p>
    <p>
        Eso es. Podemos ahora arrancar nuestra aplicación por medio de nuestro
        script principal, y va a hacer exactamente lo mismo:
    </p>
<code>node index.js</code>
    <p>
        Bien, ahora podemos poner las diferentes partes de nuestra aplicación
        en archivos diferentes y enlazarlas juntas a través de la
        creación de estos módulos.
    <p>
    <p>
        Tenemos sólo la primera parte de nuestra aplicación en su lugar:
        Podemos recibir peticiones HTTP. Pero necesitamos hacer algo con ellas - 
        necesitamos reaccionar de manera diferente, dependiendo de que 
        URL el browser requiera de nuestro servidor.
    <p>
    <p>
        Para una aplicación muy simple, podrías hacer esto directamente
        dentro de una función de callback <em>OnRequest()</em>. Pero, como dije,
        agreguemos un poco más de abstracción, de manera de hacer nuestra 
        aplicación más interesante.
    </p>
    <p>
        Hacer diferentes peticiones HTTP ir a partes diferentes de nuestro 
        código se llama "ruteo" (N. del T.: routing, en inglés) - bueno,
        entonces, creemos un módulo llamado <em>router</em>.
    </p>
 
    </article>
  </section>
  <section class="main-section" id="rutear_peticiones">
    <header>rutear peticiones</header>
    <article>
  
    <p>
        Necesitamos ser capaces de entregar la URL requerida y los posibles 
        parámetros GET o POST adicionales a nuestro router, y basado en estos,
        el router debe ser capaz de decidir qué código ejecutar (este 
        "código a ejecutar" es la tercera parte de nuestra aplicación: una
        colección de manipuladores de peticiones que harán el verdadero trabajo
        cuando una petición es recibida).
    </p>
    <p>
        Así que, Necesitamos mirar en las peticiones HTTP y extraer la URL
        requerida, así como los parámetros GET/POST de ellos. Se puede discutir
        acerca de si este procedimiento debe ser parte del router o del servidor
        (o si lo hacemos un módulo por sí mismo), pero hagamos el acuerdo de
        hacerlo parte de nuestro servidor HTTP por ahora.
    </p>
    <p>
        Toda la información que necesitamos está disponible en el objeto
        <em>request</em>, el que es pasado como primer parámetro a nuestra
        función callback <em>onRequest()</em>. Pero para interpretar esta 
        información, necesitamos algunos módulos adicionales Node.js, llamados
        <em>url</em> y <em>querystring</em>.
    </p>
    <p>
        El módulo <em>url</em> provee métodos que nos permite extraer las 
        diferentes partes de una URL (como por ejemplo la ruta requerida y 
        el string de consulta), y <em>querystring</em> puede, en cambio, ser usado
        para parsear el string de consulta para los parámetros requeridos:
    </p>
<code>                               url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/iniciar?foo=bar&amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)["foo"]    |
                                            |
                         querystring(string)["hello"]
</code>
    <p>
        Podemos, por supuesto, también utilizar <em>querystring</em> para 
        parsear el cuerpo de una petición POST en busca de parámetros, como veremos
        más tarde.
    </p>
    <p>
        Agreguemos ahora a nuestra función <em>onRequest()</em> la lógica 
        requerida para encontrar que ruta URL el browser solicitó:
    <p>
<code class="prettyprint lang-js">var http = require("http");
var url = require("url");

function iniciar() {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Petición para " + pathname + " recibida.");
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hola Mundo");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Servidor Iniciado.");
}

exports.iniciar = iniciar;
</code>
    <p>
        Muy Bien. Nuestra aplicación puede ahora distinguir peticiones
        basadas en la ruta URL requerida - esto nos permite mapear
        peticiones hacia nuestro manipuladores de peticiones, basándonos
        en la ruta URL usando nuestro (pronto a ser escrito) router. Luego, 
        podemos construir nuestra aplicación en una forma REST (N. del T.:
        RESTful way en Inglés), ya que ahora podemos implementar una interfaz que
        sigue los principios que guían a la <em>Identificación de Recursos</em>
        (ve por favor <a href="http://es.wikipedia.org/wiki/Representational_State_Transfer">el artículo de Wikipedia acerca de la Transferencia del Estado Representacional</a> para información de trasfondo.
    </p>
    <p>
        En el contexto de nuestra aplicación, esto significa simplemente que 
        seremos capaces de tener peticiones para las URLs 
        <em>/iniciar</em> y <em>/subir</em> manejadas por partes diferentes de
        nuestro código. Veremos pronto como todo esto encaja.
    <p>
    <p>
        OK, es hora de escribir nuestro router. Vamos a crear un nuevo archivo
        llamado <em>router.js</em>, con el siguiente contenido:
    </p>
<code>function route(pathname) {
  console.log("A punto de rutear una peticion para " + pathname);
}

exports.route = route;
</code>    
    <p>
        Por supuesto, este código no está haciendo nada, pero eso está bien
        por ahora. Empecemos a ver como vamos a encajar este router con nuestro
        servidor antes de poner más lógica en el router.
    </p>
    <p>
        Nuestro servidor HTTP necesita saber y hacer uso de nuestro router.
        Podemos escribir directamente esta dependencia a nuestro
        servidor, pero como hemos aprendido de la manera difícil en nuestras
        experiencias, vamos a acoplar de manera débil (<em>loose coupling</em> en Inglés)
        al router y su servidor vía inyección por dependencia. Para una referencia
        de fondo, leer el <a href="http://martinfowler.com/articles/injection.html">Artículo de Martin Fowler (en Inglés)</a>.
    </p>
        <p>
            Primero extendamos nuestra función <em>iniciar()</em> de manera de permitirnos
            pasar la función de ruteo a ser usada como parámetro:
        </p>
<code>var http = require("http");
var url = require("url");

function iniciar(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Peticion para " + pathname + " recibida.");

    route(pathname);

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hola Mundo");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Servidor Iniciado.");
}

exports.iniciar = iniciar;
</code>
    <p>
        Y extendamos nuestro <em>index.js</em> adecuadamente, esto es,
        inyectando la función de ruteo de nuestro router en el servidor:
    </p>
<code class="prettyprint lang-js">var server = require("./server");
var router = require("./router");

server.iniciar(router.route);

</code>        
    <p>
        Nuevamente , estamos pasando una función como parámetros, pero esto
        ya no es una novedad para nosotros.
    </p>
    <p>
        Si arrancamos nuestra aplicación ahora (<em>node index.js</em> como siempre),
        y hacemos una petición para una URL, puedes ver ahora por las respuestas de 
        la aplicación que nuestro servidor HTTP hace uso de nuestro router y le entrega
        el nombre de ruta requerido:
    </p>
<code class="prettyprint lang-js">bash$ node index.js
Petición para /foo recibida.
A punto de rutear una peticion para /foo
</code>
    <p>
        He omitido la molesta respuesta de la petición para /favicon.ico
    </p>
    </article>
  </section>
  <section class="main-section" id="rutear_manipulador">
    <header>rutear manipulador</header>
    <article>
 
    <p>
        Volviendo al tema. Nuestro servidor HTTP y nuestro router de peticiones son
        ahora los mejores amigos y conversan entre ellos, tal y como pretendimos.
    </p>
    <p>
        Por supuesto, esto no es suficiente, "Rutear" significa que nosotros queremos
        manipular las peticiones a distintas URLs de manera, diferente. Nos gustaría
        tener la "lógicas de negocios" para peticiones de <em>/inicio</em> manejadas
        en otra función, distinta a la que maneja las peticiones para <em>/subir</em>.
    </p>
    <p>
        Por ahora, el ruteo "termina" en el router, y el router no es el lugar donde
        se está "haciendo algo" con las peticiones, ya que esto no escalaría bien
        una vez que nuestra aplicación se haga más compleja.
    </p>
    <p>
        Llamemos a estas funciones, donde las peticiones están siendo ruteadas, 
        <em>manipuladores de peticiones</em> (ó request handlers). Y procedamos con
        éstos ahora, porque, a menos que no los tengamos en su lugar, no hay tiene
        mucho sentido en hacer nada con el router por ahora.
    </p>
    <p>
        Nueva parte de la aplicación, significa nuevo módulo - no creo que haya
        sorpresa acá. Creemos un módulo llamado requestHandlers (N. del T.: por manipuladores
        de petición), agreguemos un función de ubicación para cada manipulador de
        petición, y exportemos estos como métodos para el módulo:
    </p>
<code>">function iniciar() {
  console.log("Manipulador de petición 'iniciar' ha sido llamado.");
}

function subir() {
  console.log("Manipulador de petición 'subir' ha sido llamado.");
}

exports.iniciar = iniciar;
exports.subir = subir;
</code>
    <p>
        Esto nos permitirá atar los manipuladores de petición al router,
        dándole a nuestro router algo que rutear.
    </p>
    <p>
        Llegado a este punto, necesitamos tomar una decisión: ¿Ingresaremos 
        las rutas del módulo requestHandlers dentro del código del router
        (hard-coding), o queremos algo más de dependencia por inyección?
        Aunque en la dependencia por inyección, como cualquier otro patrón,
        no debería ser usada simplemente por usarla, en este caso tiene
        sentido acoplar el router débilmente a sus manipuladores de petición,
        así, de esta manera hacemos que el router sea reutilizable.
    </p>
    <p>
        Esto significa que necesitamos pasar los manipuladores de petición
        desde nuestro server al router, pero esto se siente equivocado, dado
        que, ¿Por qué tenemos que hacer el camino largo y entregar los manipuladores
        desde el archivo principal al servidor y de ahí al router?
    </p>
    <p>
        ¿Cómo vamos a pasarlos? Ahora tenemos sólo dos manipuladores, pero en una
        aplicación real, este número se va a incrementar y variar, y nosotros no
        queremos estar a cada momento mapeando peticiones a manipuladores cada vez
        que una nueva URL o manipulador de petición sea agregado. Y si tenemos un
        código del tipo <em>if peticion == x then llama manipulador y</em> en
        el router, esto se pondría cada vez más feo.
    </p>
    <p>
        ¿Un número variable de items, cada uno de ellos mapeados a un string?
        (en este caso la URL requerida) Bueno, esto suena como que un array asociativo
        haría el truco.
    </p>
    <p>
        Bueno, este descubrimiento es obscurecido por el hecho que JavaScript no
        provee arrays asociativos - ¿o sí? !Resulta que lo que necesitamos usar son
        objetos si necesitamos un array asociativo!
    </p>
    <p>
        Una buena introducción a esto está (en Inglés) en 
        <a href="http://msdn.microsoft.com/en-us/magazine/cc163419.aspx">http://msdn.microsoft.com/en-us/magazine/cc163419.aspx</a>,
        Déjame citarte la parte relevante:
    </p>
    <blockquote>
        <p>
            En C++ o C#, cuando hablamos acerca de objetos, nos estamos refiriendo
            a instancias de clases de estructuras. Los objetos tienen distintas
            propiedades y métodos, dependiendo en las plantillas (esto es, las clases)
            desde donde éstos sean instanciados. Este no es el caso con los objetos
            de JavaScript. En JavaScript, los objetos son sólo colecciones de pares
            nombre/valor - piensa en un objeto JavaScript como en un diccionario
            con llaves de string.
        </p>
    </blockquote>
    <p>
        Si los objetos JavaScript son sólo colecciones de pares nombre/valor, ¿Cómo
        pueden entonces tener métodos? Bueno, los valores pueden ser strings,
        números, etc... ¡O Funciones!
    </p>
    <p>
        OK, ahora, volviendo finalmente al código. Hemos decidido que queremos
        pasar la lista de requestHandlers (manipuladores de petición) como un 
        objeto, y para lograr este acoplamiento débil, necesitamos usar la técnica
        de inyectar este objeto en la <em>route()</em> (ruta).
    </p>
    <p>
        Empecemos con poner el objeto en nuestro archivo principal <em>index.js</em>:
    </p>
<code>var server = require("./server");
var router = require("./router");
var requestHandlers = require("./requestHandlers");

var handle = {}
handle["/"] = requestHandlers.iniciar;
handle["/iniciar"] = requestHandlers.iniciar;
handle["/subir"] = requestHandlers.subir;

server.iniciar(router.route, handle);
</code>
    <p>
        (N. del T.: Se Opta por dejar los verbos en Inglés 'route' para rutear
        y 'handle' para manipular).
    </p>
    <p>
        Aunque <em>handle</em> es más una "cosa" (una colección de manipuladores
        de petición), propongo que lo nombremos como un verbo, ya que esto
        resultará en una expresión fluida en nuestro router, como veremos a
        continuación:
    </p>
    <p>
        Como puedes ver, es realmente simple mapear diferentes URLs al mismo 
        manipulador de peticiones: Mediante la adición de un par llave/valor
        de <em>"/"</em> y <em>requestHandlers.iniciar</em>, podemos expresar en una
        forma agradable y limpia que no sólo peticiones a <em>/start</em>, sino 
        que también peticiones a <em>/</em> pueden ser manejadas por el manipulador
        <em>inicio</em>.
    </p>
    <p>
        Después de definir nuestro objeto, se lo pasamos al servidor como un
        parámetro adicional. Modifiquemos nuestro <em>server.js</em> para hacer uso
        de este:
    </p>
    
<code>var http = require("http");
var url = require("url");

function iniciar(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Peticion para " + pathname + " recibida.");

    route(handle, pathname);

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hola Mundo");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Servidor Iniciado.");
}

exports.iniciar = iniciar;
</code>    
    <p>
        Lo que hacemos aquí, es chequear si un manipulador de peticiones para una
        ruta dada existe, y si es así, simplemente llamamos a la función adecuada.
        Dado que podemos acceder a nuestras funciones manipuladoras de petición
        desde nuestro objeto de la misma manera que hubiésemos podido acceder a un
        elemento de un array asociativo, es que tenemos la expresión fluida
        <em>handle[pathname]();</em> de la que hablé antes, que en otras palabras es:
        "Por favor, <em>handle</em> (maneja) este(a) <em>pathname</em> (ruta)"</em>.
    </p>
    <p>
        Bien, ¡Esto es todo lo que necesitamos para atar servidor, router y 
        manipuladores de peticiones juntos! Una vez que arranquemos nuestra 
        aplicación y hagamos una petición en nuestro browser de 
        <a href="http://localhost:8888/iniciar" rel="nofollow">http://localhost:8888/iniciar</a>,
        vamos a probar que el manipulador de petición correcto fue, de hecho, llamado:
    </p>
<code>Servidor Iniciado.
Peticion para /iniciar recibida.

A punto de rutear una petición para /iniciar
Manipulador de peticion 'iniciar' ha sido llamado.
</code> 
    </article>
  </section>
  
  <section class="main-section" id="referencia">
    <header>referencia</header>
    <article>
      <ul>
        <li>
          Toda la documentacion de esta pagina es tomada de 
          https://www.nodebeginner.org/index-es.html
          
          
          <a
            href="https://www.nodebeginner.org/index-es.html"
            target="_blank"
            >MDN</a
          >
        </li>
        <li>
          tambien puede estudiar mas en 
          https://books.adalab.es/materiales-front-end-j/
           <a
            href="https://books.adalab.es/materiales-front-end-j/"
            target="_blank"
            >Material frontend</a
          >
        </li>
      </ul>
    </article>
  </section>
</main>